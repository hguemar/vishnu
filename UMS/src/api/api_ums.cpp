/**
 * \file api_ums.cpp
 * \brief This file contains the VISHNU api functions.
 * \author Daouda Traore (daouda.traore@sysfera.com) and Ibrahima Cisse (ibrahima.cisse@sysfera.com)
 * \date February 2011
 */

#include "api_ums.hpp"
#include "boost/date_time/posix_time/posix_time.hpp"
#include <boost/filesystem.hpp>
#include <boost/filesystem/fstream.hpp>

#include "SessionProxy.hpp"
#include "MachineProxy.hpp"
#include "LocalAccountProxy.hpp"
#include "OptionValueProxy.hpp"
#include "QueryProxy.hpp"
#include "UtilsProxy.hpp"
#include "utilVishnu.hpp"
#include "NetrcReader.hpp"
#include "AuthSystemProxy.hpp"
#include "AuthAccountProxy.hpp"
#include "UMSServices.hpp"
#include "UMSVishnuException.hpp"
#include "UserProxy.hpp"
#include "ObjectIdProxy.hpp"
#include "ExporterProxy.hpp"
#include "constants.hpp"

/**
 * \brief Function to open a session
 * \param userId The VISHNU user identifier
 * \param password The password of the user
 * \param session is an object containing the encrypted identifier of the session generated by VISHNU
 * \param connectOpt To encapsulate the options available for the connect method. It allows the user
 *  to choose the way for way for closing the session automatically on TIMEOUT or on DISCONNECT and the
 *  possibility for an admin to open a session as she was a specific user
 *  \return raises an exception on error
 */
int
vishnu::connect(const std::string& userId,
                const std::string& password,
                UMS_Data::Session& session,
                const UMS_Data::ConnectOptions& connectOpt)
throw(UserException, SystemException) {

  if((connectOpt.getClosePolicy() < 0) || (connectOpt.getClosePolicy() > 2)) {
    throw UMSVishnuException(ERRCODE_UNKNOWN_CLOSURE_MODE, "Invalid ClosePolicy value: its value must be 0, 1 or 2");
  }

  std::string connectLogin;
  std::string connectPassword;
  std::map<size_t, std::pair<std::string,std::string> > auth;
  std::map<size_t, std::pair<std::string,std::string> >::iterator iter;
  UMS_Data::ListUsers listUsers;
  UMS_Data::UMS_DataFactory_ptr ecoreFactory = UMS_Data::UMS_DataFactory::_instance();
  UMS_Data::User_ptr user = ecoreFactory->createUser();

  //If the userId and the password is undefined the netrc file is used
  if ((userId.empty()) && (password.empty())) {
    NetrcReader netrcReader;
    netrcReader.read(auth);

    /**
     * The map contain the user/password in different area
     * So to rebuild the full user (uid/password), browse
     * the map using binary mask to keep the data of the
     * items that are already registered to know when
     * to save the user
     */
    unsigned int state = 0x0000;
    // Convert to list of users
    for (iter = auth.begin(); iter!=auth.end(); ++iter) {
      std::pair<std::string,std::string> couple = iter->second;

      if(couple.first.compare("login")==0) {
        user->setUserId(couple.second);
        state |= 0x0001;
      }
      if(couple.first.compare("password")==0) {
        user->setPassword(couple.second);
        state |= 0x1000;
      }
      if(couple.first.compare("machine")==0) {
        continue;
      }
      if (state == 0x1001) {
        state = 0x0000;
        listUsers.getUsers().push_back(user);
        user = ecoreFactory->createUser();
      }
    }
    return connect(listUsers,
                   session,
                   connectOpt);
  } else {
    connectLogin = userId;
    connectPassword = password;
  }

  std::string encryptedPassword = vishnu::cryptPassword(connectLogin, connectPassword, false);

  UserProxy userProxy(connectLogin, encryptedPassword);
  SessionProxy sessionProxy;
  sessionProxy.connect(userProxy, connectOpt);

  session = sessionProxy.getData();

  return 0;

}

/**
 * \brief Function to open a session
 * \param users The VISHNU users identifier
 * \param session is an object containing the encrypted identifier of the session generated by VISHNU
 * \param connectOpt To encapsulate the options available for the connect method. It allows the user
 *  to choose the way for way for closing the session automatically on TIMEOUT or on DISCONNECT and the
 *  possibility for an admin to open a session as she was a specific user
 *  \return raises an exception on error
 */
int
vishnu::connect(UMS_Data::ListUsers& users,
                UMS_Data::Session& session,
                const UMS_Data::ConnectOptions& connectOpt)
throw(UserException, SystemException) {
  unsigned int cpt;
  UMS_Data::User* user;
  bool connected = false;
  int ret;
  SystemException excep;
  UMSVishnuException umsexcep;
  bool umsexcepfound = false;
  bool excepfound = false;

  for (cpt = 0; cpt < users.getUsers().size(); cpt++) {
    user = users.getUsers().at(cpt);
    std::string userId = user->getUserId();
    std::string password = user->getPassword();
    // no credentials, leaving
    if (userId.empty() || password.empty()) {
      continue;
    }
    try {
      ret = connect(userId, password, session, connectOpt);
      connected = true;
      break;
    } catch (UMSVishnuException &e) {
      umsexcep = e;
      umsexcepfound = true;
    } catch (SystemException &e) {
      excep =e;
      excepfound = true;
    }
  }
  // if no connection has been made
  if (!connected) {
    if (excepfound) {
      throw excep;
    }
    if (umsexcepfound) {
      throw umsexcep;
    }
  }
  return ret;
}


/**
 * \brief Function to return the sessionKey of a session in which the user was disconnected previously without closing it
 * \param users The VISHNU users identifier
 * \param sessionId is the identifier of the session defined in the database
 * \param session is an object containing the encrypted identifier of the session generated by VISHNU and the close policy value
 * \return raises an exception on error
 */
int
vishnu::reconnect(UMS_Data::ListUsers& users,
                  const std::string& sessionId,
                  UMS_Data::Session& session)
throw(UserException, SystemException) {
  unsigned int cpt;
  UMS_Data::User* user;
  bool reconnected = false;
  int ret;
  // For each account
  for (cpt = 0; cpt < users.getUsers().size(); cpt++) {
    user = users.getUsers().at(cpt);
    std::string userId = user->getUserId();
    std::string password = user->getPassword();
    // no credentials, leaving
    if (userId.empty() || password.empty()) {
      continue;
    }
    try {
      ret = reconnect(userId, password, sessionId, session);
      // If connection successfull
      if (ret == 0) {
        reconnected = true;
        break;
      }

      // Catching bad authentication exceptions
    } catch (UserException &e) {
    } catch (SystemException &e) {
    }
  }
  //If no user account has managed to connect
  if (!reconnected) {
    throw UMSVishnuException(ERRCODE_UNKNOWN_USER, "No account could be used to reconnect");
  }
  return ret;

}


/**
 * \brief Function to return the sessionKey of a session in which the user was disconnected previously without closing it
 * \param userId represents the VISHNU user identifier
 * \param password represents the password of the user
 * \param sessionId is the identifier of the session defined in the database
 * \param session is an object containing the encrypted identifier of the session generated by VISHNU and the close policy value
 * \return raises an exception on error
 */
int
vishnu::reconnect(const std::string& userId,
                  const std::string& password,
                  const std::string& sessionId,
                  UMS_Data::Session& session)
throw(UserException, SystemException) {

  std::string connectLogin;
  std::string connectPassword;
  std::map<size_t,std::pair<std::string,std::string> > auth;
  std::map<size_t,std::pair<std::string,std::string> >::iterator iter;
  UMS_Data::ListUsers listUsers;
  UMS_Data::UMS_DataFactory_ptr ecoreFactory = UMS_Data::UMS_DataFactory::_instance();
  UMS_Data::User_ptr user = ecoreFactory->createUser();

  //If the userId and the password is undefined the netrc file is used
  if ((userId.empty()) && (password.empty())) {
    NetrcReader netrcReader;
    netrcReader.read(auth);

    /**
     * The map contain the user/password in different area
     * So to rebuild the full user (uid/password), browse
     * the map using binary mask to keep the data of the
     * items that are already registered to know when
     * to save the user
     */
    unsigned int state = 0x0000;
    // Convert to list of users
    for (iter = auth.begin(); iter != auth.end(); ++iter) {
     std::pair<std::string, std::string> couple = iter->second;
      if (couple.first == "login") {
        user->setUserId(couple.second);
        state |= 0x0001;
      }
      if (couple.first == "password") {
        user->setPassword(couple.second);
        state |= 0x1000;
      }
      if (couple.first == "machine") {
        continue;
      }
      if (state == 0x1001) {
        state = 0x0000;
        listUsers.getUsers().push_back(user);
        user = ecoreFactory->createUser();
      }
    }
    return reconnect(listUsers, sessionId, session);

  } else {
    connectLogin = userId;
    connectPassword = password;
  }

  std::string encryptedPassword =
      vishnu::cryptPassword(connectLogin, connectPassword, false);

  UserProxy userProxy(connectLogin, encryptedPassword);
  session.setSessionId(sessionId);
  SessionProxy sessionProxy(session);

  int res = sessionProxy.reconnect(userProxy);

  session = sessionProxy.getData();

  return res;
}


/**
 * \brief Function to close the session identfied by the session key
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \return raises an exception on error
 */
int
vishnu::close(const std::string&  sessionKey)
throw(UserException, SystemException) {
  return SessionProxy(sessionKey).close();
}

/**
 * \brief Function to add a new user in VISHNU
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param newUser is an object containing the new user information
 * \return raises an exception on error
 */
int
vishnu::addUser(const std::string& sessionKey, UMS_Data::User& newUser)
throw(UserException, SystemException) {

  int privilege = newUser.getPrivilege();
  if (privilege == vishnu::PRIVILEGE_UNDEFINED) {
    newUser.setPrivilege(vishnu::PRIVILEGE_USER);
  } else {
    checkPrivilege(privilege);
  }

  int status = newUser.getStatus();
  if (status == vishnu::PRIVILEGE_UNDEFINED) {
    newUser.setStatus(vishnu::STATUS_ACTIVE);
  } else {
    checkEntityStatus(newUser.getStatus());
  }

  checkIfTextIsEmpty(newUser.getFirstname(), "The user firstname is empty", ERRCODE_INVALID_PARAM);
  checkIfTextIsEmpty(newUser.getLastname(), "The user lastname is empty", ERRCODE_INVALID_PARAM);
  checkEmail(newUser.getEmail());

  SessionProxy sessionProxy(sessionKey);
  UserProxy userProxy(sessionProxy);
  int res = userProxy.add(newUser);

  return res;
}


/**
 * \brief Function to update the user information except the userId and the password
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param user is an object containing the new user information
 * \return raises an exception on error
 */
int
vishnu::updateUser(const std::string& sessionKey,
                   const UMS_Data::User& user)
throw(UserException, SystemException) {

  int privilege = user.getPrivilege();
  if (privilege != vishnu::PRIVILEGE_UNDEFINED) {
    checkPrivilege(privilege);
  }

  int status = user.getStatus();
  if (status != vishnu::STATUS_UNDEFINED) {
    checkEntityStatus(status);
  }

  if (!user.getEmail().empty()) {
    checkEmail(user.getEmail());
  }

  SessionProxy sessionProxy(sessionKey);
  UserProxy userProxy(sessionProxy);

  return userProxy.update(user);
}


/**
 * \brief Function to remove a user from VISHNU
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param userId represents the VISHNU user identifier of the user who will be deleted from VISHNU
 * \return raises an exception on error
 */
int
vishnu::deleteUser(const std::string& sessionKey,
                   const std::string& userId)
throw(UserException, SystemException) {
  UMS_Data::User user;
  user.setUserId(userId);
  SessionProxy sessionProxy(sessionKey);
  UserProxy userProxy(sessionProxy);

  return userProxy.deleteUser(user);
}


/**
 * \brief Function to change the password
 * \param userId represents the VISHNU user identifier
 * \param password represents the password of the user
 * \param passwordNew represents the new password of the user
 * \return raises an exception on error
 */
int
vishnu::changePassword(const std::string& userId,
                       const std::string& password,
                       const std::string& passwordNew)
throw(UserException, SystemException) {
  checkIfTextIsEmpty(passwordNew, "The new password is empty",
                     ERRCODE_INVALID_PARAM);
  if (passwordNew.size()<PASSWORD_MIN_SIZE){
    throw UMSVishnuException(ERRCODE_INVALID_PARAM,
                             "The new password is too short, it must be at least 6 characters long");
  }
  if (passwordNew.size()>PASSWORD_MAX_SIZE){
    throw UMSVishnuException(ERRCODE_INVALID_PARAM,
                             "The new password is too long, it must be at most 8 characters long");
  }


  UMS_Data::User user;
  user.setUserId(userId);
  UserProxy userProxy(user);

  std::string encryptedPassword =
      vishnu::cryptPassword(userId, password, false);
  std::string encryptedPasswordNew =
      vishnu::cryptPassword(userId, passwordNew, false);

  return userProxy.changePassword(encryptedPassword, encryptedPasswordNew);
}


/**
 * \brief Function to reset the password of a user
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param userId represents represents the VISHNU user identifier of the user whose password will be reset
 * \return raises an exception on error
 */
int
vishnu::resetPassword(const std::string& sessionKey,
                      const std::string& userId,
                      std::string& tmpPassword)
throw(UserException, SystemException) {
  UMS_Data::User user;
  user.setUserId(userId);
  SessionProxy sessionProxy(sessionKey);
  UserProxy userProxy(sessionProxy);

  int res = userProxy.resetPassword(user);
  tmpPassword = (userProxy.getData()).getPassword();
  return res;
}


/**
 * \brief Function to add a new machine in VISHNU
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param newMachine is an object which encapsulates the information of the machine which will be added in VISHNU except the
 * machine id which will be created automatically by VISHNU
 * \return raises an exception on error
 */
int
vishnu::addMachine(const std::string& sessionKey,
                   UMS_Data::Machine& newMachine)
throw(UserException, SystemException)
{
  checkIfTextIsEmpty(newMachine.getName(),
                     "The machine name is empty",
                     ERRCODE_INVALID_PARAM);
  checkIfTextIsEmpty(newMachine.getSite(),
                     "The machine site is empty",
                     ERRCODE_INVALID_PARAM);
  checkIfTextIsEmpty(newMachine.getLanguage(),
                     "The machine language is empty",
                     ERRCODE_INVALID_PARAM);
  checkIfTextIsEmpty(newMachine.getMachineDescription(),
                     "The machine description is empty",
                     ERRCODE_INVALID_PARAM);

  SessionProxy sessionProxy(sessionKey);
  MachineProxy machineProxy(newMachine, sessionProxy);
  int res = machineProxy.add();
  newMachine = machineProxy.getData();

  return res;
}


/**
 * \brief Function to update machine description
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param machine is an existing machine information
 * \return raises an exception on error
 */
int
vishnu::updateMachine(const std::string& sessionKey,
                      const UMS_Data::Machine& machine)
throw(UserException, SystemException) {

  int status = machine.getStatus();
  if (status != vishnu::STATUS_UNDEFINED) {
    checkEntityStatus(status);
  }

  SessionProxy sessionProxy(sessionKey);
  MachineProxy machineProxy(machine, sessionProxy);

  return machineProxy.update();
}


/**
 * \brief Function to remove a machine from VISHNU
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param machineId represents the identifier of the machine
 * \return raises an exception on error
 */
int
vishnu::deleteMachine(const std::string& sessionKey,
                      const std::string& machineId)
throw(UserException, SystemException) {
  UMS_Data::Machine machine;
  machine.setMachineId(machineId);
  SessionProxy sessionProxy(sessionKey);
  MachineProxy machineProxy(machine, sessionProxy);

  return machineProxy.deleteMachine();
}


/**
 * \brief Function to add a new local user configuration
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param newLocalAccount is is the object which encapsulates the new local user configuration
 * \param sshPublicKey the SSH public key generated by VISHNU for accessing a local account (deprecated)
 * \return raises an exception on error
 */
int
vishnu::addLocalAccount(const std::string& sessionKey,
                        const UMS_Data::LocalAccount& newLocalAccount,
                        std::string& sshPublicKey)
throw(UserException, SystemException) {

  checkIfTextIsEmpty(newLocalAccount.getUserId(),
                     "The local account userId is empty",
                     ERRCODE_INVALID_PARAM);
  checkIfTextIsEmpty(newLocalAccount.getMachineId(),
                     "The local account machineId is empty",
                     ERRCODE_INVALID_PARAM);
  checkIfTextIsEmpty(newLocalAccount.getAcLogin(),
                     "The local account acLogin is empty",
                     ERRCODE_INVALID_PARAM);
  checkIfTextIsEmpty(newLocalAccount.getHomeDirectory(),
                     "The local account home directory is empty",
                     ERRCODE_INVALID_PARAM);

  SessionProxy sessionProxy(sessionKey);
  LocalAccountProxy localAccountProxy(newLocalAccount, sessionProxy);

  int res = localAccountProxy.add();

  return res;
}


/**
 * \brief Function to update a local user configuration
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param localAccount is an object which encapsulates the local user configuration changes except the machineId and the userId
 * \return raises an exception on error
 */
int
vishnu::updateLocalAccount(const std::string& sessionKey,
                           const UMS_Data::LocalAccount& localAccount)
throw(UserException, SystemException) {

  SessionProxy sessionProxy(sessionKey);
  LocalAccountProxy localAccountProxy(localAccount, sessionProxy);

  return localAccountProxy.update();
}


/**
 * \brief Function to removes a local user configuration (for a given user on a given machine) from VISHNU
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param userId represents the VISHNU user identifier of the user whose local configuration will be deleted for the given machine
 * \param machineId represents the identifier of the machine whose local configuration will be deleted for the given user
 * \return raises an exception on error
 */
int
vishnu::deleteLocalAccount(const std::string& sessionKey,
                           const std::string& userId,
                           const std::string& machineId)
throw(UserException, SystemException) {
  UMS_Data::LocalAccount localAccount;
  localAccount.setUserId(userId);
  localAccount.setMachineId(machineId);
  SessionProxy sessionProxy(sessionKey);
  LocalAccountProxy localAccountProxy(localAccount, sessionProxy);

  return localAccountProxy.deleteLocalAccount();
}


/**
 * \brief Function to configure an option of the user
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param optionValue is an object which encapsulates the option information
 * \return raises an exception on error
 */
int
vishnu::configureOption(const std::string& sessionKey,
                        const UMS_Data::OptionValue& optionValue)
throw(UserException, SystemException) {
  checkIfTextIsEmpty(optionValue.getOptionName(),
                     "The name of the option is empty",
                     ERRCODE_INVALID_PARAM);
  checkIfTextIsEmpty(optionValue.getValue(),
                     "The value of the option is empty",
                     ERRCODE_INVALID_PARAM);

  SessionProxy sessionProxy(sessionKey);
  OptionValueProxy optionValueProxy(optionValue, sessionProxy);

  return optionValueProxy.configureOption();
}

/**
 * \brief Function to configure a default option value
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param optionValue is an object which encapsulates the option information
 * \return raises an exception on error
 */
int
vishnu::configureDefaultOption(const std::string& sessionKey,
                               const UMS_Data::OptionValue& optionValue)
throw(UserException, SystemException) {
  checkIfTextIsEmpty(optionValue.getOptionName(),
                     "The name of the option is empty",
                     ERRCODE_INVALID_PARAM);
  checkIfTextIsEmpty(optionValue.getValue(),
                     "The value of the option is empty",
                     ERRCODE_INVALID_PARAM);

  SessionProxy sessionProxy(sessionKey);
  OptionValueProxy optionValueProxy(optionValue, sessionProxy);

  return optionValueProxy.configureDefaultOption();
}


/**
 * \brief Function to list all sessions of the user
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param listSession is an object which encapsulates the list of sessions
 * \param options allows the user to list sessions using several optional criteria such as: the state of sessions (actives or
 * inactives, by default, all sessions are listed), a period, a specific session or for admin to list all sessions of all
 * users or sessions of a specific user.
 * \return raises an exception on error
 */
int
vishnu::listSessions(const std::string& sessionKey,
                     UMS_Data::ListSessions& listSession,
                     const UMS_Data::ListSessionOptions& options)
throw(UserException, SystemException) {
  if((options.getSessionClosePolicy() < 0) ||
     (options.getSessionClosePolicy() > 2)) {
    throw
    UMSVishnuException(ERRCODE_UNKNOWN_CLOSURE_MODE,
                       "Invalid ClosePolicy value: its value must be 0, 1 or 2");
  }

  checkEntityStatus(options.getStatus());

  SessionProxy sessionProxy(sessionKey);
  QueryProxy<UMS_Data::ListSessionOptions,
      UMS_Data::ListSessions> query(options, sessionProxy,
                                    SERVICES_UMS[SESSIONLIST]);

  UMS_Data::ListSessions* listSession_ptr = query.list();

  if (listSession_ptr) {
    UMS_Data::UMS_DataFactory_ptr ecoreFactory =
        UMS_Data::UMS_DataFactory::_instance();

    for (unsigned int i = 0; i < listSession_ptr->getSessions().size(); i++) {
      UMS_Data::Session_ptr session = ecoreFactory->createSession();
      //To copy the content and not the pointer
      *session = *listSession_ptr->getSessions().get(i);
      listSession.getSessions().push_back(session);
    }
    delete  listSession_ptr;
  }

  return 0;
}


/**
 * \brief Function to list the local user configurations
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param listLocalAcc is an object which encapsulates the list of the local user configuations
 * \param options allows an admin to list all local configurations of all users or a simple user to list his/her local user configurations on a
 * specific machine
 * \return raises an exception on error
 */
int
vishnu::listLocalAccounts(const std::string& sessionKey,
                          UMS_Data::ListLocalAccounts& listLocalAcc,
                          const UMS_Data::ListLocalAccOptions& options)
throw(UserException, SystemException) {
  SessionProxy sessionProxy(sessionKey);
  QueryProxy<UMS_Data::ListLocalAccOptions,
      UMS_Data::ListLocalAccounts> query(options, sessionProxy,
                                         SERVICES_UMS[LOCALACCOUNTLIST]);

  UMS_Data::ListLocalAccounts* listLocalAcc_ptr = query.list();

  if (listLocalAcc_ptr) {
    UMS_Data::UMS_DataFactory_ptr ecoreFactory =
        UMS_Data::UMS_DataFactory::_instance();
    for (unsigned int i = 0; i < listLocalAcc_ptr->getAccounts().size(); i++) {
      UMS_Data::LocalAccount_ptr account = ecoreFactory->createLocalAccount();
      //To copy the content and not the pointer
      *account = *listLocalAcc_ptr->getAccounts().get(i);
      listLocalAcc.getAccounts().push_back(account);
    }
    delete listLocalAcc_ptr;
  }

  return 0;
}


/**
 * \brief Function to list the machines in which the local user configurations are defined for the given user
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param listMachine is an object which encapsulates the list of the machines
 * \param options allows a user to list all VISHNU machines or information about a specific machine and an admin to list machines used by
 * a specific user
 * \return raises an exception on error
 */
int
vishnu::listMachines(const std::string& sessionKey,
                     UMS_Data::ListMachines& listMachine,
                     const UMS_Data::ListMachineOptions& options)
throw(UserException, SystemException) {
  SessionProxy sessionProxy(sessionKey);
  QueryProxy<UMS_Data::ListMachineOptions,
      UMS_Data::ListMachines> query(options, sessionProxy,
                                    SERVICES_UMS[MACHINELIST]);
  UMS_Data::ListMachines* listMachine_ptr = query.list();

  if (listMachine_ptr) {
    UMS_Data::UMS_DataFactory_ptr ecoreFactory =
        UMS_Data::UMS_DataFactory::_instance();
    for (unsigned int i = 0; i < listMachine_ptr->getMachines().size(); i++) {
      UMS_Data::Machine_ptr machine = ecoreFactory->createMachine();
      //To copy the content and not the pointer
      *machine = *listMachine_ptr->getMachines().get(i);
      listMachine.getMachines().push_back(machine);
    }
    delete listMachine_ptr;
  }
  return 0;
}


/**
 * \brief Function to list the commands
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param listCommands is an object which encapsulates the list of commands
 * \param options allows the user to list commands by using several optional criteria: a period, specific session and for admin
 * to list all commands of all VISHNU users or commands from a specific user
 * \return raises an exception on error
 */
int
vishnu::listHistoryCmd(const std::string& sessionKey,
                       UMS_Data::ListCommands& listCommands,
                       const UMS_Data::ListCmdOptions& options)
throw(UserException, SystemException) {
  SessionProxy sessionProxy(sessionKey);
  QueryProxy<UMS_Data::ListCmdOptions,
      UMS_Data::ListCommands> query(options, sessionProxy,
                                    SERVICES_UMS[COMMANDLIST]);

  UMS_Data::ListCommands* listCommands_ptr = query.list();

  if (listCommands_ptr) {
    UMS_Data::UMS_DataFactory_ptr ecoreFactory =
        UMS_Data::UMS_DataFactory::_instance();
    for (unsigned int i = 0; i < listCommands_ptr->getCommands().size(); i++) {
      UMS_Data::Command_ptr command = ecoreFactory->createCommand();
      //To copy the content and not the pointer
      *command = *listCommands_ptr->getCommands().get(i);
      listCommands.getCommands().push_back(command);
    }
    delete listCommands_ptr;
  }

  return 0;
}

/**
 * \brief Function to list the options of the user
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param listOptValues is an object which encapsulates the list of options
 * \param options allows to list a specific option or all default options values or for an admin to list options of a specific user
 * \return raises an exception on error
 */
int
vishnu::listOptions(const std::string& sessionKey,
                    UMS_Data::ListOptionsValues& listOptValues,
                    const UMS_Data::ListOptOptions& options)
throw(UserException, SystemException) {
  SessionProxy sessionProxy(sessionKey);
  QueryProxy<UMS_Data::ListOptOptions,
      UMS_Data::ListOptionsValues> query(options, sessionProxy,
                                         SERVICES_UMS[OPTIONVALUELIST]);

  UMS_Data::ListOptionsValues* listOptValues_ptr = query.list();

  if (listOptValues_ptr) {
    UMS_Data::UMS_DataFactory_ptr ecoreFactory =
        UMS_Data::UMS_DataFactory::_instance();
    for (unsigned int i = 0; i < listOptValues_ptr->getOptionValues().size();
         i++) {
      UMS_Data::OptionValue_ptr optionValue = ecoreFactory->createOptionValue();
      //To copy the content and not the pointer
      *optionValue = *listOptValues_ptr->getOptionValues().get(i);
      listOptValues.getOptionValues().push_back(optionValue);
    }
    delete listOptValues_ptr;
  }

  return 0;
}

/**
 * \brief Function to list VISHNU users
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param listUsers is an object which encapsulates the list of users
 * \param options allows an admin to get information about a specific user identified by his/her userId
 * \return raises an exception on error
 */

int
vishnu::listUsers(const std::string& sessionKey,
                  UMS_Data::ListUsers& listUsers,
                  const UMS_Data::ListUsersOptions& listOptions )
throw(UserException, SystemException) {
  SessionProxy sessionProxy(sessionKey);
  QueryProxy<UMS_Data::ListUsersOptions,
      UMS_Data::ListUsers> query(listOptions, sessionProxy,
                                 SERVICES_UMS[USERLIST]);

  UMS_Data::ListUsers* listUsers_ptr = query.list();

  if (listUsers_ptr) {
    UMS_Data::UMS_DataFactory_ptr ecoreFactory =
        UMS_Data::UMS_DataFactory::_instance();
    for (unsigned int i = 0; i < listUsers_ptr->getUsers().size(); i++) {
      UMS_Data::User_ptr user = ecoreFactory->createUser();
      //To copy the content and not the pointer
      *user = *listUsers_ptr->getUsers().get(i);
      listUsers.getUsers().push_back(user);
    }
    delete listUsers_ptr;
  }

  return 0;
}


/***
 * \brief Function to update a user-authentication system in VISHNU
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param newAuthSys is an object which encapsulates the information of the
 * user-authentication system which will be added in
 * VISHNU
 * \param options is an object which encapsulates the information of the
 * user-authentication system which will be added in
 * VISHNU
 */
int
vishnu::addAuthSystem(const std::string& sessionKey,
                      UMS_Data::AuthSystem& newAuthSys)
throw(UserException, SystemException) {
  if (newAuthSys.getType() != LDAPTYPE) {
    throw UMSVishnuException(ERRCODE_UNKNOWN_AUTH_SYSTEM_TYPE, "Invalid type");
  }

  if (newAuthSys.getType()==LDAPTYPE &&
      (std::string(newAuthSys.getLdapBase()).empty())) {
    throw UMSVishnuException(ERRCODE_UNKNOWN_AUTH_SYSTEM_TYPE,
                             "Missing ldap base");
  }

  if (newAuthSys.getUserPasswordEncryption() != SSHA_METHOD ) {
    throw UMSVishnuException(ERRCODE_UNKNOWN_ENCRYPTION_METHOD,
                             "Invalid encryption method");
  }

  checkIfTextIsEmpty(newAuthSys.getName(),
                     "The authentication name is empty",
                     ERRCODE_INVALID_PARAM);
  checkIfTextIsEmpty(newAuthSys.getURI(),
                     "The authentication item is empty",
                     ERRCODE_INVALID_PARAM);
  checkIfTextIsEmpty(newAuthSys.getAuthLogin(),
                     "The authentication login is empty",
                     ERRCODE_INVALID_PARAM);
  checkIfTextIsEmpty(newAuthSys.getAuthPassword(),
                     "The authentication password is empty",
                     ERRCODE_INVALID_PARAM);

  SessionProxy sessionProxy(sessionKey);
  AuthSystemProxy auth(newAuthSys, sessionProxy);
  auth.add();
  newAuthSys = auth.getData();

  return 0;
}


/***
 * \brief Function to add a new user-authentication system in VISHNU
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param authSysis an object which encapsulates the information of the
 * user-authentication system which will be added in
 * VISHNU
 */
int
vishnu::updateAuthSystem(const std::string& sessionKey,
                         UMS_Data::AuthSystem& authSys)
throw(UserException, SystemException) {
  SessionProxy sessionProxy(sessionKey);
  AuthSystemProxy auth(authSys, sessionProxy);

  if (authSys.getType() < -1 || authSys.getType() > 0) {
    throw UMSVishnuException(ERRCODE_UNKNOWN_AUTH_SYSTEM_TYPE, "Invalid type");
  }

  checkEntityStatus(authSys.getStatus());

  if (authSys.getUserPasswordEncryption()<-1 ||
      authSys.getUserPasswordEncryption()>0 ) {
    throw UMSVishnuException(ERRCODE_UNKNOWN_ENCRYPTION_METHOD,
                             "Invalid encryption method");
  }

  auth.update();
  authSys = auth.getData();

  return 0;
}


/***
 * \brief Function to remove a user-authentication system from VISHNU
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param authSystemId authSystemId is the identifier of the user-authentication
 * system
 */
int
vishnu::deleteAuthSystem(const std::string& sessionKey,
                         const std::string& authSystemId)
throw(UserException, SystemException) {
  UMS_Data::AuthSystem sys;
  sys.setAuthSystemId(authSystemId);
  SessionProxy sessionProxy(sessionKey);
  AuthSystemProxy auth(sys, sessionProxy);

  return auth.deleteAuthSystem();
}


/***
 * \brief Function to lists VISHNU user-authentification systems
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param listAuthSys is the list of the user-authentication systems
 * \param options allows an admin to list all user-authentication systems
 * used by a specific user or a user to list all
 * user-authentication systems declared in VISHNU (and
 * not only those where a local user-authentication configs
 * are defined). It also allows to list user-authentication
 * systems of a specific type
 */
int
vishnu::listAuthSystems(const std::string& sessionKey,
                        UMS_Data::ListAuthSystems& listAuthSys,
                        const UMS_Data::ListAuthSysOptions& options)
throw(UserException, SystemException) {
  SessionProxy sessionProxy(sessionKey);
  QueryProxy<UMS_Data::ListAuthSysOptions,
      UMS_Data::ListAuthSystems> query(options, sessionProxy,
                                       SERVICES_UMS[AUTHSYSTEMLIST]);

  UMS_Data::ListAuthSystems* list = query.list();

  if (list) {
    UMS_Data::UMS_DataFactory_ptr ecoreFactory =
        UMS_Data::UMS_DataFactory::_instance();
    for (unsigned int i = 0; i < list->getAuthSystems().size(); i++) {
      UMS_Data::AuthSystem_ptr auth = ecoreFactory->createAuthSystem();
      //To copy the content and not the pointer
      *auth = *list->getAuthSystems().get(i);
      listAuthSys.getAuthSystems().push_back(auth);
    }
    delete list;
  }

  return 0;
}


/***
 * \brief Function to add a new local user-authentication configuration
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param authAccount is an object which encapsulates the information of the
 * local user-authentication configuration which will be
 * added in VISHNU
 */
int
vishnu::addAuthAccount(const std::string& sessionKey,
                       const UMS_Data::AuthAccount& authAccount)
throw(UserException, SystemException) {
  checkIfTextIsEmpty(authAccount.getAuthSystemId(),
                     "The authentication account systemId is empty",
                     ERRCODE_INVALID_PARAM);
  checkIfTextIsEmpty(authAccount.getAcLogin(),
                     "The authentication acc login is empty",
                     ERRCODE_INVALID_PARAM);

  SessionProxy sessionProxy(sessionKey);
  AuthAccountProxy auth(authAccount, sessionProxy);

  return auth.add();
}


/***
 * \brief Function to add a new local user-authentication configuration
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param authenAccount is an object which encapsulates the information of the
 * local user-authentication configuration which will be
 * updated
 */
int
vishnu::updateAuthAccount(const std::string& sessionKey,
                          const UMS_Data::AuthAccount& authAccount)
throw(UserException, SystemException) {
  SessionProxy sessionProxy(sessionKey);
  AuthAccountProxy auth(authAccount, sessionProxy);

  return auth.update();
}


/***
 * \brief Function to removes a local user-authentication configuration from
 * VISHNU
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param authSystemId authSystemId is the identifier of the user-authentication
 * system
 * \param userIdOption is an admin option which represents the VISHNU
 * identifier of the user whose local user-authentication
 * configuration will be deleted
 */
int
vishnu::deleteAuthAccount(const std::string& sessionKey,
                          const std::string& authSystemId,
                          const std::string& userId)
throw(UserException, SystemException) {
  UMS_Data::AuthAccount authAccount;
  authAccount.setUserId(userId);
  authAccount.setAuthSystemId(authSystemId);
  SessionProxy sessionProxy(sessionKey);
  AuthAccountProxy authAccountProxy(authAccount, sessionProxy);

  return authAccountProxy.deleteAuthAccount();
}


/***
 * \brief Function to lists local user-authentication configurations
 * \param sessionKey is the encrypted identifier of the session generated by VISHNU
 * \param listAuthAccounts is the list of the local user-authentication
 * configurations
 * \param options allows an admin to list all local user-authentication
 * configurations or to list local user-authentication
 * configurations of a specific user or for a user to list local
 * user-authentication configuration defined for a specific
 * user-authentication system
 */
int
vishnu::listAuthAccounts(const std::string& sessionKey,
                         UMS_Data::ListAuthAccounts& listAuthAccounts,
                         const UMS_Data::ListAuthAccOptions& options)
throw(UserException, SystemException) {
  SessionProxy sessionProxy(sessionKey);
  QueryProxy<UMS_Data::ListAuthAccOptions,
      UMS_Data::ListAuthAccounts> query(options, sessionProxy,
                                        SERVICES_UMS[AUTHACCOUNTLIST]);

  UMS_Data::ListAuthAccounts* list = query.list();

  if (list) {
    UMS_Data::UMS_DataFactory_ptr ecoreFactory =
        UMS_Data::UMS_DataFactory::_instance();
    for (unsigned int i = 0; i < list->getAuthAccounts().size(); i++) {
      UMS_Data::AuthAccount_ptr auth = ecoreFactory->createAuthAccount();
      //To copy the content and not the pointer
      *auth = *list->getAuthAccounts().get(i);
      listAuthAccounts.getAuthAccounts().push_back(auth);
    }
    delete list;
  }

  return 0;
}


/**
 * \brief Function to initialize the SYSFERA-DS configuration
 * \param cfg The SYSFERA-DS configuration file
 * \param argc The number of arguments of the program
 * \param argv The list of arguments
 * \return an error code
 */
int
vishnu::vishnuInitialize(char* cfg, int argc, char** argv) {
  return UtilsProxy(cfg, argc, argv).initialize();
}

/**
 * \brief Function to finalize, currently useless
 */
void
vishnu::vishnuFinalize(){
}

int
vishnu::defineUserIdentifier(const std::string& sessionKey,
                             const std::string& fmt)
throw (UserException, SystemException) {
  SessionProxy sessionProxy(sessionKey);

  ObjectIdProxy ob(sessionProxy);
  ob.setUID(fmt);
  return 0;
}


int
vishnu::defineMachineIdentifier(const std::string& sessionKey,
                                const std::string& fmt)
throw (UserException, SystemException) {
  SessionProxy sessionProxy(sessionKey);

  ObjectIdProxy ob(sessionProxy);
  ob.setMID(fmt);
  return 0;
}


int
vishnu::defineJobIdentifier(const std::string& sessionKey,
                            const std::string& fmt)
throw (UserException, SystemException) {
  SessionProxy sessionProxy(sessionKey);

  ObjectIdProxy ob(sessionProxy);
  ob.setTID(fmt);
  return 0;
}


int
vishnu::defineTransferIdentifier(const std::string& sessionKey,
                                 const std::string& fmt)
throw (UserException, SystemException) {
  SessionProxy sessionProxy(sessionKey);

  ObjectIdProxy ob(sessionProxy);
  ob.setFID(fmt);
  return 0;
}

int
vishnu::defineAuthIdentifier(const std::string& sessionKey,
                             const std::string& fmt)
throw (UserException, SystemException) {
  SessionProxy sessionProxy(sessionKey);

  ObjectIdProxy ob(sessionProxy);
  ob.setAID(fmt);
  return 0;
}

int
vishnu::defineWorkIdentifier(const std::string& sessionKey,
                             const std::string& fmt)
throw (UserException, SystemException) {
  SessionProxy sessionProxy(sessionKey);

  ObjectIdProxy ob(sessionProxy);
  ob.setWID(fmt);
  return 0;
}

int
vishnu::exportCommands(const std::string& sessionKey,
                       const std::string& oldSessionId,
                       const std::string& filename)
  throw (UserException, SystemException) {

  boost::filesystem::path file (filename);
  // Check the existence of file
  if (((false== boost::filesystem::exists(file)) ||
       (true== boost::filesystem::is_directory(file))) ||
      (false== boost::filesystem::is_regular_file(file))) {
    throw UserException(ERRCODE_INVALID_PARAM, "The file: " + filename +" is a directory or does not exists");
  }

  SessionProxy sessionProxy(sessionKey);
  ExporterProxy exporterProxy(sessionProxy);
  exporterProxy.exportCmd(oldSessionId, filename);

  return 0;
}
